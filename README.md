# アルゴリズムとデータ構造

[問題解決力を鍛える!アルゴリズムとデータ構造](https://www.amazon.co.jp/%E5%95%8F%E9%A1%8C%E8%A7%A3%E6%B1%BA%E5%8A%9B%E3%82%92%E9%8D%9B%E3%81%88%E3%82%8B-%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0-KS%E6%83%85%E5%A0%B1%E7%A7%91%E5%AD%A6%E5%B0%82%E9%96%80%E6%9B%B8-%E5%A4%A7%E6%A7%BB-%E5%85%BC%E8%B3%87/dp/4065128447/ref=pd_lpo_14_t_0/358-8530093-5372456?_encoding=UTF8&pd_rd_i=4065128447&pd_rd_r=a10830dd-ad31-4f4d-9ba7-c5cf264d11df&pd_rd_w=Ci38Q&pd_rd_wg=Jf9Y4&pf_rd_p=dc0198fa-c371-4787-b1e2-96ed0e4d45e8&pf_rd_r=AECFZC511YXMTZF8HKE2&psc=1&refRID=AECFZC511YXMTZF8HKE2)で学んだことのメモ

## サンプルコードの実行

- ts
  - tsディレクトリへ移動
  - `yarn` を実行
  - `yarn ts-node src/xxx.ts` を実行

## 1章

- 二分探索法(binary search)
  - 整列済みの数値を真ん中で切って、半分ずつ調べていく

- 線形探索法(linear search)
  - 順々に調べていく方法

- 深さ優先探索
  - グラフ検索において、複数ある選択肢からいけるところまで進み、だめなら別の選択肢を試す方法

- 幅優先探索
  - 深さとは逆で他の選択肢を全て見てから進む方法

## 2章

- 計算量
  - アルゴリズムの善し悪しを図る物差し
  - ランダウのＯ記法がある

- 計算量の求め方(ざっくり)
  - 最大次数のみ扱う
  - 係数は無視する
  - 例えば、3n^2 + 5n + 100の場合
    - 5n + 100は無視する
    - 3n^2の3は無視する
    - 結果、O(n^2)となる
    - 詳細は、極限計算を参照

- 入力サイズと計算ステップの関係
  - `logN` は高速
  - 善し悪しの境目は、 `NlogN` と `N^2` の間にありそう
    - ただし、Nが小さい場合は`N^2`でも現実的な時がある

- O(1)を定数時間という
  - データの扱いを間違えると、O(N)になることがある
  - `if v in S:` の`S`はハッシュテーブルだとO(1)となるが、リストで扱うとO(N)になる

- 計算量の種類
  - 時間計算量
    - 実行時間
  - 領域計算量
    - 実行時にどのくらいのメモリを使うか

## 3章

- 全探索
  - 全探索は時間はかかるが、パターンを理解する上重要
    - 数が小さければ全探索でも問題なし

- 線形探索法
  - 一つずつ順番に探索していく方法
    - 3-2.ts
  - 応用
    - 条件を満たす場所を調べる
      - 3-3-1.ts
    - 最小値を求める
      - 3-3-2.ts

- 全探索
  - ペアの全探索
    - 3-4.ts
  - 組み合わせの全探索
  - 集合の全組み合わせは 2^Nとなる
  - これを走査するには、bit操作が良い
    - 3-5.ts

## 4章

- 再帰呼び出し
  - 処理中に自身のことを呼び出すこと
  - 4-1.ts

- ユークリッドの互除法
  - 整数m,nの最大公約数($GCD(m,n)$)を求めるアルゴリズム
  - 4-2.ts

- フィボナッチ数列
  - $F_0=0$
  - $F_1=1$
  - $F_N=F_{N-1}+F_{N-2}...(N=2,3...)$
  - 4-3.ts

- メモ化
  - フィボナッチ数列は同じ計算を何度もやるので、一度実施した計算はメモ化すると効率が良い
  - 配列を使ったやり方にすると$O(N)$となる
    - 4-4.ts
  - キャッシュを使ったやり方も$O(N)$となる
    - 動的計画法(dynamic programming)と呼ばれる

- 部分和問題
  - 前回はビット操作により計算したが、再帰処理で実現する
  - ２つに分けて考えられ、いずれかを満たす場合は$W$を満たす組み合わせがあるといえる
  - $N-1$個の整数$a_0, a_1...a_{N-2}$から$W$を作れるか
    - さらに、$N-2$個の整数$a_0, a_1...a_{N-3}$から$W$を作れるか導くことが出来る
  - $N-1$個の整数$a_0, a_1...a_{N-2}$から$W-a_{N-1}$を作れるか
    - $N-2$個の整数$a_0, a_1...a_{N-3}$から$W-a_{N-1}-a_{N-2}$が作れるか導くことが出来る
  - 計算量は、$O(2^N)$となる
  - 4-5.ts

- 分割統治法
  - 与えられた課題を部分問題とし、それらの解を組み合わせて問題の解を導き出すアルゴリズム技法
  - 例えば、マージソートがあげられる

## 5章

- 動的計画法
  - 大きな問題を小さな問題に分解し、分解後の解をメモ化しながら、その解を組み合わせて大きな問題を解く手法

- Frog問題(AtCoderより)
  - お題をグラフで表すとよりわかりやすくなる
  - 動的計画法を使うことで計算量は、$O(N)$となる
  - 5-1.ts

- 緩和
  - dp配列の各値が徐々に小さい値に更新されていく様子。詳細は後ほど。
  - 5-3-1.ts

- Frog問題を再帰的に解くことも可能
  - これでは計算回数が多い状態なので、**メモ化再帰**を行う
    - 再帰処理の中で、一度実施した処理はメモ化すること
    - 5-3-2.ts

- 動的計画法
  - ナップサック問題
    - Frog問題では添え字が足りないのでその分の添え字を増やして対応する
    - 5-4.ts
  - 編集距離
    - 2つの文字列、S、Tの類似度を測るもの
      - 例
        - diff コマンド
        - スペルチェッカー
        - 空間認識、画像認識
        - etc...
      - 5-5.ts

## 6章

- 二分探索法
  - ソート済みの配列(ソートの計算量は $O(NlogN)$ となるが、12章で触れる)
  - 2部探索法の計算量は $O(logN)$ となる
  - 6-1.ts

## 7章

- 貪欲法
  - 後先のことは考えずに目の前のことに最善を尽くす方法
  - 例) X円を支払うのに、500/100/50/10/5/1円の硬貨をもっている状態で使用する硬貨数を少なくするには？
    - Xを超えない範囲で500円から多く使っていく、次は100円を多く使っていく...
  - 貪欲法が必ずしも最適解になるとは限らない

## 12章

- ソート
  - in-placeが有効
    - 追加メモリが不要
  - 安定性がある
    - 同じ値が来ても順番が保証される

- 挿入ソート
 - 平均計算量: $O(N^2)$
 - 最悪計算量: $O(N^2)$
 - 安定性:o
 - in-place: o
 - insertion.ts

- マージソート
  - 平均計算量: $O(NlogN)$
  - 最悪計算量: $O(NlogN)$
 - 安定性:o
 - in-place: o
## appendix

- [DFS (深さ優先探索) 超入門！ 〜 グラフ・アルゴリズムの世界への入口 〜【前編】](https://qiita.com/drken/items/4a7869c5e304883f539b)
- [計算量オーダーの求め方を総整理！ 〜 どこから log が出て来るか 〜](https://qiita.com/drken/items/872ebc3a2b5caaa4a0d0)


## TODO

- 数式の書式化
- format